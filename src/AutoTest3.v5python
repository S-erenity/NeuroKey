{"mode":"Text","textContent":"# Donut Run – Smooth & Stable (reduced speed + slew rate), Competition Template\nfrom vex import *\n\n# ---- Brain & Controller ----\nbrain = Brain()\ncontroller = Controller(PRIMARY)\n\n# ---- Drivetrain Motors (6:1 ≈ 600 RPM gear) ----\nleftA  = Motor(Ports.PORT1,  GearSetting.RATIO_6_1, False)\nleftB  = Motor(Ports.PORT2,  GearSetting.RATIO_6_1, False)\nrightA = Motor(Ports.PORT9,  GearSetting.RATIO_6_1, False)\nrightB = Motor(Ports.PORT10, GearSetting.RATIO_6_1, False)\n\nLeftSide  = MotorGroup(leftA, leftB)\nRightSide = MotorGroup(rightA, rightB)\n\n# Softer torque so starts/turns are gentler\nfor m in (leftA, leftB, rightA, rightB):\n    m.set_max_torque(80, PERCENT)  # reduce peak torque to soften motion\n\n# Gentle stopping to avoid payload jerks\nLeftSide.set_stopping(COAST)\nRightSide.set_stopping(COAST)\n\nwait(30, MSEC)  # let devices init\n\n# -----------------------------\n# Helpers: Slew-rate (smooth accel/decel)\n# -----------------------------\ndef _slew_toward(current: float, target: float, step: float) -> float:\n    \"\"\"Move current speed toward target by at most 'step' per update.\"\"\"\n    if target > current:\n        current += step\n        if current > target:\n            current = target\n    elif target < current:\n        current -= step\n        if current < target:\n            current = target\n    return current\n\n# -----------------------------\n# Encoder-straight with smoothing (no gyro)\n# -----------------------------\ndef drive_straight(distance_mm: float,\n                   base_speed_pct: float = 55,   # nerfed speed (was 100)\n                   kP: float = 0.18,             # mild correction for stability\n                   slew_step: float = 2.0,       # % per loop (≈100%/s at 20ms loop)\n                   min_speed_pct: float = 12):   # keep from stalling at low speeds\n    \"\"\"\n    Smooth, encoder-corrected straight drive.\n    Positive distance -> forward; negative -> reverse.\n    \"\"\"\n    wheel_diam_mm = 101.6  # 4\" wheels\n    wheel_circ = wheel_diam_mm * 3.1415926\n    target_turns = abs(distance_mm) / wheel_circ\n    forward = distance_mm > 0\n\n    # Reset encoders\n    LeftSide.set_position(0, TURNS)\n    RightSide.set_position(0, TURNS)\n\n    # Start from zero speed; we'll ramp up with slew\n    cur_left = 0.0\n    cur_right = 0.0\n\n    # While the \"leading\" side hasn't reached the target\n    while abs(LeftSide.position(TURNS)) < target_turns and abs(RightSide.position(TURNS)) < target_turns:\n        left_pos  = LeftSide.position(TURNS)\n        right_pos = RightSide.position(TURNS)\n        error = left_pos - right_pos     # +error => left went farther\n\n        # Compute target speeds with gentle proportional correction\n        correction = error * (kP * 100.0)  # scale since speeds are in %\n        tgt_left   = base_speed_pct - correction\n        tgt_right  = base_speed_pct + correction\n\n        # Clamp targets\n        tgt_left  = max(min(tgt_left,  base_speed_pct), -base_speed_pct)\n        tgt_right = max(min(tgt_right, base_speed_pct), -base_speed_pct)\n\n        # Maintain a small minimum so we don't stall at very low duty\n        if forward:\n            tgt_left  = max(tgt_left,  min_speed_pct)\n            tgt_right = max(tgt_right, min_speed_pct)\n        else:\n            tgt_left  = min(tgt_left,  -min_speed_pct)\n            tgt_right = min(tgt_right, -min_speed_pct)\n\n        # Slew toward targets for smooth accel/decel\n        cur_left  = _slew_toward(cur_left,  tgt_left,  slew_step)\n        cur_right = _slew_toward(cur_right, tgt_right, slew_step)\n\n        # Spin motors\n        if forward:\n            LeftSide.spin(FORWARD,  cur_left,  PERCENT)\n            RightSide.spin(FORWARD, cur_right, PERCENT)\n        else:\n            LeftSide.spin(REVERSE,  -cur_left,  PERCENT)   # keep speeds positive in REVERSE\n            RightSide.spin(REVERSE, -cur_right, PERCENT)\n\n        wait(20, MSEC)\n\n    # Smooth stop: ramp down to 0 to avoid a jolt\n    for _ in range(12):  # ~240ms taper\n        cur_left  = _slew_toward(cur_left,  0, 4)\n        cur_right = _slew_toward(cur_right, 0, 4)\n        if forward:\n            LeftSide.spin(FORWARD,  cur_left,  PERCENT)\n            RightSide.spin(FORWARD, cur_right, PERCENT)\n        else:\n            LeftSide.spin(REVERSE,  -cur_left,  PERCENT)\n            RightSide.spin(REVERSE, -cur_right, PERCENT)\n        wait(20, MSEC)\n\n    LeftSide.stop(COAST)\n    RightSide.stop(COAST)\n\n# -----------------------------\n# Smooth, timed turn-in-place (no gyro)\n# -----------------------------\ndef turn_in_place_smooth(degrees: float,\n                         turn_speed_pct: float = 35,  # nerfed speed for stability\n                         total_time_s: float = 2.30,  # tune on field for ~180°\n                         ramp_portion: float = 0.25): # fraction of time spent ramping\n    \"\"\"\n    Smooth spin-in-place using a gentle ramp up/down.\n    Use degrees≈180 with a timed duration tuned for your robot.\n    \"\"\"\n    # Direction: positive degrees -> left forward/right reverse\n    left_dir = FORWARD if degrees >= 0 else REVERSE\n    right_dir = REVERSE if degrees >= 0 else FORWARD\n\n    # Timing windows\n    ramp_time = total_time_s * ramp_portion\n    cruise_time = total_time_s - 2 * ramp_time\n\n    # Start from 0 and ramp up\n    cur = 0.0\n    step = max(2.0, turn_speed_pct / (ramp_time / 0.02))  # step per 20ms\n\n    # Ramp up\n    t = 0.0\n    while t < ramp_time:\n        cur = min(cur + step, turn_speed_pct)\n        LeftSide.spin(left_dir,  cur, PERCENT)\n        RightSide.spin(right_dir, cur, PERCENT)\n        wait(20, MSEC)\n        t += 0.02\n\n    # Cruise\n    t = 0.0\n    while t < cruise_time:\n        LeftSide.spin(left_dir,  turn_speed_pct, PERCENT)\n        RightSide.spin(right_dir, turn_speed_pct, PERCENT)\n        wait(20, MSEC)\n        t += 0.02\n\n    # Ramp down\n    t = 0.0\n    while t < ramp_time:\n        cur = max(cur - step, 0)\n        LeftSide.spin(left_dir,  cur, PERCENT)\n        RightSide.spin(right_dir, cur, PERCENT)\n        wait(20, MSEC)\n        t += 0.02\n\n    LeftSide.stop(COAST)\n    RightSide.stop(COAST)\n\n# -----------------------------\n# Autonomous\n# -----------------------------\ndef autonomous():\n    brain.screen.clear_screen()\n    brain.screen.print(\"🍩 Smooth Donut Run\")\n\n    # Forward ~30 ft (≈ 9140 mm) at reduced, smoothed speed\n    drive_straight(9140, base_speed_pct=55, kP=0.18, slew_step=2.0, min_speed_pct=12)\n\n    # Smooth 180° turn (slow + ramped to avoid slipping)\n    # Tune total_time_s on your field if needed (±0.1–0.2s)\n    turn_in_place_smooth(180, turn_speed_pct=35, total_time_s=2.30, ramp_portion=0.25)\n\n    # Return to start\n    drive_straight(9140, base_speed_pct=55, kP=0.18, slew_step=2.0, min_speed_pct=12)\n\n    brain.screen.clear_screen()\n    brain.screen.print(\"✅ Done (stable)\")\n\n# -----------------------------\n# Driver control (kept minimal)\n# -----------------------------\ndef drivercontrol():\n    while True:\n        wait(20, MSEC)\n\n# -----------------------------\n# Competition wiring\n# -----------------------------\ncomp = Competition(drivercontrol, autonomous)\n\n# Keep program alive\nwhile True:\n    wait(100, MSEC)\n","textLanguage":"python","rconfig":[{"port":[1,2],"name":"LeftSide","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","gear":"ratio18_1","motor_a_reversed":"false","motor_b_reversed":"false"},"triportSourcePort":22},{"port":[9,10],"name":"RightSide","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","gear":"ratio18_1","motor_a_reversed":"false","motor_b_reversed":"false"},"triportSourcePort":22},{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22}],"slot":0,"platform":"V5","sdkVersion":"20220215.18.00.00","appVersion":"2.3.1","fileFormat":"1.0.1","icon":"","targetBrainGen":"First","target":"Physical"}