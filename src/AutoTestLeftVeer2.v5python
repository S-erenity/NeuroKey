{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code (generated)\nLeftSide_motor_a = Motor(Ports.PORT1, GearSetting.RATIO_18_1, False)\nLeftSide_motor_b = Motor(Ports.PORT2, GearSetting.RATIO_18_1, False)\nLeftSide = MotorGroup(LeftSide_motor_a, LeftSide_motor_b)\nRightSide_motor_a = Motor(Ports.PORT9, GearSetting.RATIO_18_1, False)\nRightSide_motor_b = Motor(Ports.PORT10, GearSetting.RATIO_18_1, False)\nRightSide = MotorGroup(RightSide_motor_a, RightSide_motor_b)\ncontroller_1 = Controller(PRIMARY)\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n#endregion VEXcode Generated Robot Configuration\n\n\n# Donut Run ‚Äì Auto-on-Start, 200 RPM, 360¬∞ In-Place Turn + Bias-Trim Straight\nfrom vex import *\n\n# ---- Brain ----\nbrain = Brain()\n\n# ---- Robot geometry ----\nWHEEL_DIAM_MM   = 101.6    # 4\" wheels\nTRACK_WIDTH_MM  = 300.0    # center-to-center distance between left/right contact patches\n\n# ---- Drivetrain Motors (18:1 = ~200 RPM) ----\nleftA  = Motor(Ports.PORT1,  GearSetting.RATIO_18_1, False)\nleftB  = Motor(Ports.PORT2,  GearSetting.RATIO_18_1, False)\n# Right side typically needs reversed=True on mirrored drivetrains\nrightA = Motor(Ports.PORT9,  GearSetting.RATIO_18_1, True)\nrightB = Motor(Ports.PORT10, GearSetting.RATIO_18_1, True)\n\nLeftSide  = MotorGroup(leftA, leftB)\nRightSide = MotorGroup(rightA, rightB)\n\n# Softer torque + gentle stopping to protect the donut\nfor m in (leftA, leftB, rightA, rightB):\n    m.set_max_torque(80, PERCENT)\nLeftSide.set_stopping(COAST)\nRightSide.set_stopping(COAST)\n\nwait(30, MSEC)  # init\n\n# ---------- helpers ----------\ndef _slew_toward(cur: float, tgt: float, step: float) -> float:\n    if tgt > cur:\n        cur = tgt if cur + step > tgt else cur + step\n    elif tgt < cur:\n        cur = tgt if cur - step < tgt else cur - step\n    return cur\n\ndef _clamp(x, lo, hi):\n    return hi if x > hi else lo if x < lo else x\n\n# ---------- improved straight (encoder-corrected + bias trim) ----------\ndef drive_straight(distance_mm: float,\n                   base_speed_pct: float = 45,\n                   kP: float = 0.22,            # stronger steering correction\n                   slew_step: float = 2.0,\n                   min_speed_pct: float = 10,\n                   bias_trim_pct: float = 0.0): # + slows LEFT / speeds RIGHT; - does opposite\n    \"\"\"\n    Smooth, encoder-corrected straight drive (no gyro).\n    - Stops on the AVERAGE of left/right distances (more robust).\n    - bias_trim_pct cancels consistent drift without rewiring.\n      * If it veers RIGHT -> use +1 to +3.\n      * If it veers LEFT  -> use -1 to -3.\n    \"\"\"\n    wheel_circ = WHEEL_DIAM_MM * 3.1415926\n    target_turns = abs(distance_mm) / wheel_circ\n    forward = distance_mm > 0\n\n    LeftSide.set_position(0, TURNS)\n    RightSide.set_position(0, TURNS)\n\n    cur_left = 0.0\n    cur_right = 0.0\n\n    while True:\n        L = LeftSide.position(TURNS)\n        R = RightSide.position(TURNS)\n\n        # Average progress (stop when avg reaches target)\n        avg_turns = (abs(L) + abs(R)) * 0.5\n        if avg_turns >= target_turns:\n            break\n\n        # Steering correction from encoder mismatch\n        error = L - R                      # + => left ahead\n        corr  = error * (kP * 100.0)       # convert to percent domain\n\n        # Apply base speeds + trim + correction\n        tgt_left  = base_speed_pct - corr + bias_trim_pct\n        tgt_right = base_speed_pct + corr - bias_trim_pct\n\n        # Clamp & keep a small minimum so we don‚Äôt stall\n        tgt_left  = _clamp(tgt_left,  -base_speed_pct, base_speed_pct)\n        tgt_right = _clamp(tgt_right, -base_speed_pct, base_speed_pct)\n\n        if forward:\n            tgt_left  = max(tgt_left,  min_speed_pct)\n            tgt_right = max(tgt_right, min_speed_pct)\n        else:\n            tgt_left  = min(tgt_left,  -min_speed_pct)\n            tgt_right = min(tgt_right, -min_speed_pct)\n\n        # Slew toward targets (smooth accel/decel)\n        cur_left  = _slew_toward(cur_left,  tgt_left,  slew_step)\n        cur_right = _slew_toward(cur_right, tgt_right, slew_step)\n\n        # Spin in correct directions (pass positive magnitude on REVERSE)\n        if forward:\n            LeftSide.spin(FORWARD,  cur_left,  PERCENT)\n            RightSide.spin(FORWARD, cur_right, PERCENT)\n        else:\n            LeftSide.spin(REVERSE,  abs(cur_left),  PERCENT)\n            RightSide.spin(REVERSE, abs(cur_right), PERCENT)\n\n        wait(20, MSEC)\n\n    # Gentle taper to zero\n    for _ in range(12):\n        cur_left  = _slew_toward(cur_left,  0, 4)\n        cur_right = _slew_toward(cur_right, 0, 4)\n        if forward:\n            LeftSide.spin(FORWARD,  cur_left,  PERCENT)\n            RightSide.spin(FORWARD, cur_right, PERCENT)\n        else:\n            LeftSide.spin(REVERSE,  abs(cur_left),  PERCENT)\n            RightSide.spin(REVERSE, abs(cur_right), PERCENT)\n        wait(20, MSEC)\n\n    LeftSide.stop(COAST); RightSide.stop(COAST)\n\n# ---------- gentle, encoder-precise in-place turn ----------\ndef turn_in_place_degrees(degrees: float,\n                          base_speed_pct: float = 30,  # slow & gentle for payload\n                          kP: float = 0.20,            # keep sides matched\n                          slew_step: float = 2.0,\n                          min_speed_pct: float = 8):\n    \"\"\"\n    In-place pivot by encoder distance (no gyro).\n    Positive degrees => turn LEFT (left forward, right reverse).\n    Uses wheel travel so it's consistent across RPM/battery.\n    \"\"\"\n    # Each wheel travels arc length s = pi * TRACK_WIDTH * (deg/360)\n    arc_len_mm = 3.1415926 * TRACK_WIDTH_MM * (abs(degrees) / 360.0)\n    wheel_circ = WHEEL_DIAM_MM * 3.1415926\n    target_turns = arc_len_mm / wheel_circ\n\n    # Reset encoders\n    LeftSide.set_position(0, TURNS)\n    RightSide.set_position(0, TURNS)\n\n    # Directions for a left (+) or right (-) pivot\n    left_dir  = FORWARD if degrees >= 0 else REVERSE\n    right_dir = REVERSE if degrees >= 0 else FORWARD\n\n    cur_left  = 0.0\n    cur_right = 0.0\n\n    while True:\n        L = abs(LeftSide.position(TURNS))\n        R = abs(RightSide.position(TURNS))\n\n        # Stop when the average of the two sides reaches target\n        if (L + R) * 0.5 >= target_turns:\n            break\n\n        # Keep the sides matched using proportional correction\n        error = L - R                     # + => left ahead\n        corr  = error * (kP * 100.0)\n\n        tgt_left  = base_speed_pct - corr\n        tgt_right = base_speed_pct + corr\n\n        # Minimum duty so it doesn't stall, with clamping\n        tgt_left  = _clamp(max(tgt_left,  min_speed_pct), min_speed_pct, base_speed_pct)\n        tgt_right = _clamp(max(tgt_right, min_speed_pct), min_speed_pct, base_speed_pct)\n\n        # Slew toward targets (smooth accel/decel)\n        cur_left  = _slew_toward(cur_left,  tgt_left,  slew_step)\n        cur_right = _slew_toward(cur_right, tgt_right, slew_step)\n\n        # Spin with explicit directions; pass positive magnitudes\n        LeftSide.spin(left_dir,  abs(cur_left),  PERCENT)\n        RightSide.spin(right_dir, abs(cur_right), PERCENT)\n\n        wait(20, MSEC)\n\n    # Soft stop\n    for _ in range(10):\n        cur_left  = _slew_toward(cur_left,  0, 5)\n        cur_right = _slew_toward(cur_right, 0, 5)\n        LeftSide.spin(left_dir,  abs(cur_left),  PERCENT)\n        RightSide.spin(right_dir, abs(cur_right), PERCENT)\n        wait(20, MSEC)\n\n    LeftSide.stop(COAST); RightSide.stop(COAST)\n\n# ---------- autonomous ----------\ndef autonomous():\n    brain.screen.clear_screen()\n    brain.screen.print(\"üç© Auto: Straight ‚Üí 360¬∞ Pivot ‚Üí Back\")\n\n    # forward ~30 ft (~9140 mm) ‚Äî trimmed to cancel left veer\n    drive_straight(9140, base_speed_pct=45, kP=0.22, slew_step=2.0, min_speed_pct=10, bias_trim_pct=-2.5)\n\n    # slow, gentle 360¬∞ in-place turn (left by default; use -360 for right)\n    turn_in_place_degrees(360, base_speed_pct=30, kP=0.20, slew_step=2.0, min_speed_pct=8)\n\n    # straight back ~30 ft ‚Äî same trim value\n    drive_straight(9140, base_speed_pct=45, kP=0.22, slew_step=2.0, min_speed_pct=10, bias_trim_pct=-2.5)\n\n    brain.screen.clear_screen()\n    brain.screen.print(\"‚úÖ Auto Done\")\n\n# ---------- auto-start ----------\nautonomous()\n\n# keep program alive\nwhile True:\n    wait(100, MSEC)\n","textLanguage":"python","rconfig":[{"port":[1,2],"name":"LeftSide","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","gear":"ratio18_1","motor_a_reversed":"false","motor_b_reversed":"false"},"triportSourcePort":22},{"port":[9,10],"name":"RightSide","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","gear":"ratio18_1","motor_a_reversed":"false","motor_b_reversed":"false"},"triportSourcePort":22},{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22}],"slot":0,"platform":"V5","sdkVersion":"20220215.18.00.00","appVersion":"2.3.1","fileFormat":"1.0.1","icon":"","targetBrainGen":"First","target":"Physical"}