{"mode":"Text","textContent":"# Donut Run ‚Äì Smooth & Stable (200 RPM, Encoder ARC Turn, Practice Mode + Competition Safe)\nfrom vex import *\n\n# ---- Brain & Controller ----\nbrain = Brain()\ncontroller = Controller(PRIMARY)\n\n# ---- Robot geometry (adjust if needed) ----\nWHEEL_DIAM_MM   = 101.6    # 4\" wheels\nTRACK_WIDTH_MM  = 300.0    # distance between left/right wheel contact patches (‚âà280‚Äì330 typical)\n\n# ---- Drivetrain Motors (18:1 = ~200 RPM cartridges) ----\nleftA  = Motor(Ports.PORT1,  GearSetting.RATIO_18_1, False)\nleftB  = Motor(Ports.PORT2,  GearSetting.RATIO_18_1, False)\nrightA = Motor(Ports.PORT9,  GearSetting.RATIO_18_1, False)\nrightB = Motor(Ports.PORT10, GearSetting.RATIO_18_1, False)\n\nLeftSide  = MotorGroup(leftA, leftB)\nRightSide = MotorGroup(rightA, rightB)\n\n# Softer torque and gentle stopping for payload stability\nfor m in (leftA, leftB, rightA, rightB):\n    m.set_max_torque(80, PERCENT)\nLeftSide.set_stopping(COAST)\nRightSide.set_stopping(COAST)\n\nwait(30, MSEC)  # let devices init\n\n# -----------------------------\n# Helpers (slew + clamps)\n# -----------------------------\ndef _slew_toward(current: float, target: float, step: float) -> float:\n    if target > current:\n        current += step\n        if current > target: current = target\n    elif target < current:\n        current -= step\n        if current < target: current = target\n    return current\n\ndef _clamp(x, lo, hi): \n    return hi if x > hi else lo if x < lo else x\n\n# -----------------------------\n# Smooth straight (encoder-corrected, no gyro)\n# -----------------------------\ndef drive_straight(distance_mm: float,\n                   base_speed_pct: float = 45,   # nerfed for 200 RPM\n                   kP: float = 0.16,             # mild correction for stability\n                   slew_step: float = 1.8,       # smooth accel/decel\n                   min_speed_pct: float = 10):   # keep from stalling\n    \"\"\"Smooth, encoder-corrected straight drive (no gyro).\"\"\"\n    wheel_circ = WHEEL_DIAM_MM * 3.1415926\n    target_turns = abs(distance_mm) / wheel_circ\n    forward = distance_mm > 0\n\n    LeftSide.set_position(0, TURNS)\n    RightSide.set_position(0, TURNS)\n\n    cur_left = 0.0\n    cur_right = 0.0\n\n    while abs(LeftSide.position(TURNS)) < target_turns and abs(RightSide.position(TURNS)) < target_turns:\n        left_pos  = LeftSide.position(TURNS)\n        right_pos = RightSide.position(TURNS)\n        error = left_pos - right_pos  # + => left ahead\n\n        correction = error * (kP * 100.0)\n        tgt_left   = base_speed_pct - correction\n        tgt_right  = base_speed_pct + correction\n\n        # clamp & minimums\n        tgt_left  = _clamp(tgt_left,  -base_speed_pct, base_speed_pct)\n        tgt_right = _clamp(tgt_right, -base_speed_pct, base_speed_pct)\n\n        if forward:\n            tgt_left  = max(tgt_left,  min_speed_pct)\n            tgt_right = max(tgt_right, min_speed_pct)\n        else:\n            tgt_left  = min(tgt_left,  -min_speed_pct)\n            tgt_right = min(tgt_right, -min_speed_pct)\n\n        # slew toward targets\n        cur_left  = _slew_toward(cur_left,  tgt_left,  slew_step)\n        cur_right = _slew_toward(cur_right, tgt_right, slew_step)\n\n        # spin\n        if forward:\n            LeftSide.spin(FORWARD,  cur_left,  PERCENT)\n            RightSide.spin(FORWARD, cur_right, PERCENT)\n        else:\n            # pass positive magnitude with REVERSE\n            LeftSide.spin(REVERSE,  abs(cur_left),  PERCENT)\n            RightSide.spin(REVERSE, abs(cur_right), PERCENT)\n\n        wait(20, MSEC)\n\n    # taper to zero to avoid a jolt\n    for _ in range(12):  # ~240 ms\n        cur_left  = _slew_toward(cur_left,  0, 4)\n        cur_right = _slew_toward(cur_right, 0, 4)\n        if forward:\n            LeftSide.spin(FORWARD,  cur_left,  PERCENT)\n            RightSide.spin(FORWARD, cur_right, PERCENT)\n        else:\n            LeftSide.spin(REVERSE,  abs(cur_left),  PERCENT)\n            RightSide.spin(REVERSE, abs(cur_right), PERCENT)\n        wait(20, MSEC)\n\n    LeftSide.stop(COAST)\n    RightSide.stop(COAST)\n\n# -----------------------------\n# Gentle C-arc by encoders (both sides forward at different speeds)\n# -----------------------------\ndef drive_arc(radius_mm: float,\n              degrees: float,\n              turn_left: bool = True,\n              base_speed_pct: float = 35,   # gentle overall pace\n              slew_step: float = 1.6,       # smooth accel\n              min_speed_pct: float = 8,     # prevent stall on inner wheel\n              sync_kP: float = 0.12):       # keep wheels synchronized\n    \"\"\"\n    Drive a circular arc (like a 'C') with both sides moving forward.\n    radius_mm: centerline radius of the robot's path.\n    degrees: arc sweep; use 180 for a half-circle.\n    turn_left: True => left is inner wheel, right is outer.\n    \"\"\"\n    # Path lengths for inner/outer wheels:\n    # inner radius = R - TRACK/2 ; outer radius = R + TRACK/2\n    R_in  = max(10.0, radius_mm - TRACK_WIDTH_MM * 0.5)\n    R_out = radius_mm + TRACK_WIDTH_MM * 0.5\n    theta = abs(degrees) * 3.1415926 / 180.0\n\n    s_in  = R_in  * theta\n    s_out = R_out * theta\n\n    wheel_circ = WHEEL_DIAM_MM * 3.1415926\n    turns_in   = s_in  / wheel_circ\n    turns_out  = s_out / wheel_circ\n\n    # Speed ratio so both finish together\n    ratio = s_in / s_out if s_out > 0 else 1.0\n    spd_out = base_speed_pct\n    spd_in  = max(min_speed_pct, base_speed_pct * ratio)\n\n    # Reset encoders\n    LeftSide.set_position(0, TURNS)\n    RightSide.set_position(0, TURNS)\n\n    # Targets per side (depends on left/right arc)\n    if turn_left:\n        target_left_turns  = turns_in\n        target_right_turns = turns_out\n        left_is_inner = True\n    else:\n        target_left_turns  = turns_out\n        target_right_turns = turns_in\n        left_is_inner = False\n\n    cur_left = 0.0\n    cur_right = 0.0\n\n    # Run until both sides hit their targets\n    while True:\n        L = abs(LeftSide.position(TURNS))\n        R = abs(RightSide.position(TURNS))\n\n        left_done  = L >= target_left_turns\n        right_done = R >= target_right_turns\n        if left_done and right_done:\n            break\n\n        # Pick targets per side based on inner/outer speed plan\n        tgt_left  = spd_in  if left_is_inner else spd_out\n        tgt_right = spd_out if left_is_inner else spd_in\n\n        # Synchronize progress: compare fractional completion\n        frac_L = L / target_left_turns  if target_left_turns  > 0 else 1.0\n        frac_R = R / target_right_turns if target_right_turns > 0 else 1.0\n        sync_err = frac_L - frac_R  # + => left ahead (go a tad slower left / faster right)\n\n        # Apply gentle sync correction\n        corr = sync_err * (sync_kP * 100.0)\n        tgt_left  = _clamp(tgt_left  - corr, min_speed_pct, base_speed_pct)\n        tgt_right = _clamp(tgt_right + corr, min_speed_pct, base_speed_pct)\n\n        # If a side already met target, hold it near zero to avoid overshoot\n        if left_done:  tgt_left  = 0.0\n        if right_done: tgt_right = 0.0\n\n        # Slew toward targets\n        cur_left  = _slew_toward(cur_left,  tgt_left,  slew_step)\n        cur_right = _slew_toward(cur_right, tgt_right, slew_step)\n\n        # Spin forward both sides (this is what makes it a smooth arc)\n        LeftSide.spin(FORWARD,  cur_left,  PERCENT)\n        RightSide.spin(FORWARD, cur_right, PERCENT)\n\n        wait(20, MSEC)\n\n    # Soft stop\n    for _ in range(8):\n        cur_left  = _slew_toward(cur_left,  0, 4)\n        cur_right = _slew_toward(cur_right, 0, 4)\n        LeftSide.spin(FORWARD,  cur_left,  PERCENT)\n        RightSide.spin(FORWARD, cur_right, PERCENT)\n        wait(20, MSEC)\n\n    LeftSide.stop(COAST)\n    RightSide.stop(COAST)\n\n# -----------------------------\n# Autonomous: forward, gentle C-arc, straight back\n# -----------------------------\ndef autonomous():\n    brain.screen.clear_screen()\n    brain.screen.print(\"üç© Auto: Straight ‚Üí C-Arc ‚Üí Back\")\n\n    # Forward ~30 ft (‚âà 9140 mm) at reduced, smoothed speed (200 RPM friendly)\n    drive_straight(9140, base_speed_pct=45, kP=0.16, slew_step=1.8, min_speed_pct=10)\n\n    # Gentle left C-arc 180¬∞ with ~0.5 m radius (tune radius for your field)\n    # To arc right instead: set turn_left=False\n    drive_arc(radius_mm=500, degrees=180, turn_left=True,\n              base_speed_pct=35, slew_step=1.6, min_speed_pct=8, sync_kP=0.12)\n\n    # Return to start (straight ~30 ft). Note: path will be offset laterally by the arc.\n    drive_straight(9140, base_speed_pct=45, kP=0.16, slew_step=1.8, min_speed_pct=10)\n\n    brain.screen.clear_screen()\n    brain.screen.print(\"‚úÖ Auto Done\")\n\n# -----------------------------\n# Driver control (minimal; add your teleop if needed)\n# -----------------------------\ndef drivercontrol():\n    while True:\n        wait(20, MSEC)\n\n# -----------------------------\n# Competition wiring\n# -----------------------------\ncomp = Competition(drivercontrol, autonomous)\n\n# -----------------------------\n# Practice Mode (runs when not on field control)\n# Press A to run autonomous once; B to stop motors.\n# -----------------------------\ndef practice_mode():\n    brain.screen.clear_screen()\n    brain.screen.print(\"Practice: A=Auto  B=Stop\")\n    while True:\n        if controller.buttonA.pressing():\n            autonomous()\n            brain.screen.clear_screen()\n            brain.screen.print(\"Practice: A=Auto  B=Stop\")\n            wait(300, MSEC)  # debounce\n        if controller.buttonB.pressing():\n            LeftSide.stop(COAST)\n            RightSide.stop(COAST)\n            brain.screen.clear_screen()\n            brain.screen.print(\"Stopped\")\n            wait(300, MSEC)\n            brain.screen.clear_screen()\n            brain.screen.print(\"Practice: A=Auto  B=Stop\")\n        wait(20, MSEC)\n\n# Start practice mode so you can trigger Auto from the controller\npractice_mode()\n","textLanguage":"python","rconfig":[{"port":[1,2],"name":"LeftSide","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","gear":"ratio18_1","motor_a_reversed":"false","motor_b_reversed":"false"},"triportSourcePort":22},{"port":[9,10],"name":"RightSide","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","gear":"ratio18_1","motor_a_reversed":"false","motor_b_reversed":"false"},"triportSourcePort":22},{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22}],"slot":0,"platform":"V5","sdkVersion":"20220215.18.00.00","appVersion":"2.3.1","fileFormat":"1.0.1","icon":"","targetBrainGen":"First","target":"Physical"}