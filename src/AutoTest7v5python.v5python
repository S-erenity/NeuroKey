{"mode":"Text","textContent":"# Donut Run ‚Äì Auto-on-Start, 200 RPM, Gentle C-Arc + Smooth Return\nfrom vex import *\n\n# ---- Brain ----\nbrain = Brain()\n\n# ---- Robot geometry ----\nWHEEL_DIAM_MM   = 101.6    # 4\" wheels\nTRACK_WIDTH_MM  = 300.0    # center-to-center distance between left/right contact patches\n\n# ---- Drivetrain Motors (18:1 = ~200 RPM) ----\nleftA  = Motor(Ports.PORT1,  GearSetting.RATIO_18_1, False)\nleftB  = Motor(Ports.PORT2,  GearSetting.RATIO_18_1, False)\n# IMPORTANT: right side typically needs reversed=True on mirrored drivetrains\nrightA = Motor(Ports.PORT9,  GearSetting.RATIO_18_1, True)\nrightB = Motor(Ports.PORT10, GearSetting.RATIO_18_1, True)\n\nLeftSide  = MotorGroup(leftA, leftB)\nRightSide = MotorGroup(rightA, rightB)\n\n# Softer torque + gentle stopping to protect the donut\nfor m in (leftA, leftB, rightA, rightB):\n    m.set_max_torque(80, PERCENT)\nLeftSide.set_stopping(COAST)\nRightSide.set_stopping(COAST)\n\nwait(30, MSEC)  # init\n\n# ---------- helpers ----------\ndef _slew_toward(cur: float, tgt: float, step: float) -> float:\n    if tgt > cur:\n        cur = tgt if cur + step > tgt else cur + step\n    elif tgt < cur:\n        cur = tgt if cur - step < tgt else cur - step\n    return cur\n\ndef _clamp(x, lo, hi): \n    return hi if x > hi else lo if x < lo else x\n\n# ---------- smooth straight (encoder corrected) ----------\ndef drive_straight(distance_mm: float,\n                   base_speed_pct: float = 45,\n                   kP: float = 0.16,\n                   slew_step: float = 1.8,\n                   min_speed_pct: float = 10):\n    wheel_circ = WHEEL_DIAM_MM * 3.1415926\n    target_turns = abs(distance_mm) / wheel_circ\n    forward = distance_mm > 0\n\n    LeftSide.set_position(0, TURNS)\n    RightSide.set_position(0, TURNS)\n\n    curL = 0.0; curR = 0.0\n\n    while abs(LeftSide.position(TURNS)) < target_turns and abs(RightSide.position(TURNS)) < target_turns:\n        L = LeftSide.position(TURNS)\n        R = RightSide.position(TURNS)\n        error = L - R                          # + => left ahead\n        corr = error * (kP * 100.0)\n\n        tgtL = _clamp(base_speed_pct - corr, -base_speed_pct, base_speed_pct)\n        tgtR = _clamp(base_speed_pct + corr, -base_speed_pct, base_speed_pct)\n\n        if forward:\n            tgtL = max(tgtL,  min_speed_pct)\n            tgtR = max(tgtR,  min_speed_pct)\n        else:\n            tgtL = min(tgtL, -min_speed_pct)\n            tgtR = min(tgtR, -min_speed_pct)\n\n        curL = _slew_toward(curL, tgtL, slew_step)\n        curR = _slew_toward(curR, tgtR, slew_step)\n\n        if forward:\n            LeftSide.spin(FORWARD,  curL, PERCENT)\n            RightSide.spin(FORWARD, curR, PERCENT)\n        else:\n            LeftSide.spin(REVERSE,  abs(curL), PERCENT)\n            RightSide.spin(REVERSE, abs(curR), PERCENT)\n\n        wait(20, MSEC)\n\n    # soft taper\n    for _ in range(12):\n        curL = _slew_toward(curL, 0, 4)\n        curR = _slew_toward(curR, 0, 4)\n        if forward:\n            LeftSide.spin(FORWARD,  curL, PERCENT)\n            RightSide.spin(FORWARD, curR, PERCENT)\n        else:\n            LeftSide.spin(REVERSE,  abs(curL), PERCENT)\n            RightSide.spin(REVERSE, abs(curR), PERCENT)\n        wait(20, MSEC)\n\n    LeftSide.stop(COAST); RightSide.stop(COAST)\n\n# ---------- gentle C-arc (both sides forward) ----------\ndef drive_arc(radius_mm: float,\n              degrees: float,\n              turn_left: bool = True,\n              base_speed_pct: float = 35,\n              slew_step: float = 1.6,\n              min_speed_pct: float = 8,\n              sync_kP: float = 0.12):\n    # inner/outer path lengths\n    R_in  = max(10.0, radius_mm - TRACK_WIDTH_MM * 0.5)\n    R_out = radius_mm + TRACK_WIDTH_MM * 0.5\n    theta = abs(degrees) * 3.1415926 / 180.0\n    s_in, s_out = R_in * theta, R_out * theta\n\n    wheel_circ = WHEEL_DIAM_MM * 3.1415926\n    turns_in, turns_out = s_in / wheel_circ, s_out / wheel_circ\n\n    # plan speeds so both finish together\n    ratio  = s_in / s_out if s_out > 0 else 1.0\n    spdOut = base_speed_pct\n    spdIn  = max(min_speed_pct, base_speed_pct * ratio)\n\n    LeftSide.set_position(0, TURNS)\n    RightSide.set_position(0, TURNS)\n\n    if turn_left:\n        tgtL_turns, tgtR_turns = turns_in, turns_out\n        left_is_inner = True\n    else:\n        tgtL_turns, tgtR_turns = turns_out, turns_in\n        left_is_inner = False\n\n    curL = 0.0; curR = 0.0\n\n    while True:\n        L = abs(LeftSide.position(TURNS))\n        R = abs(RightSide.position(TURNS))\n        left_done  = L >= tgtL_turns\n        right_done = R >= tgtR_turns\n        if left_done and right_done:\n            break\n\n        tgtL = spdIn  if left_is_inner else spdOut\n        tgtR = spdOut if left_is_inner else spdIn\n\n        # sync by fractional progress\n        fracL = L / tgtL_turns if tgtL_turns > 0 else 1.0\n        fracR = R / tgtR_turns if tgtR_turns > 0 else 1.0\n        sync_err = fracL - fracR              # + => left ahead\n        corr = sync_err * (sync_kP * 100.0)\n        tgtL = _clamp(tgtL - corr, min_speed_pct, base_speed_pct)\n        tgtR = _clamp(tgtR + corr, min_speed_pct, base_speed_pct)\n\n        if left_done:  tgtL = 0.0\n        if right_done: tgtR = 0.0\n\n        curL = _slew_toward(curL, tgtL, slew_step)\n        curR = _slew_toward(curR, tgtR, slew_step)\n\n        LeftSide.spin(FORWARD,  curL, PERCENT)\n        RightSide.spin(FORWARD, curR, PERCENT)\n        wait(20, MSEC)\n\n    # soft stop\n    for _ in range(8):\n        curL = _slew_toward(curL, 0, 4)\n        curR = _slew_toward(curR, 0, 4)\n        LeftSide.spin(FORWARD,  curL, PERCENT)\n        RightSide.spin(FORWARD, curR, PERCENT)\n        wait(20, MSEC)\n\n    LeftSide.stop(COAST); RightSide.stop(COAST)\n\n# ---------- autonomous ----------\ndef autonomous():\n    brain.screen.clear_screen()\n    brain.screen.print(\"üç© Auto: Straight ‚Üí C-Arc ‚Üí Back\")\n\n    # forward ~30 ft (~9140 mm)\n    drive_straight(9140, base_speed_pct=45, kP=0.16, slew_step=1.8, min_speed_pct=10)\n\n    # gentle LEFT C-arc 180¬∞; make turn_left=False to arc right instead\n    drive_arc(radius_mm=500, degrees=180, turn_left=True,\n              base_speed_pct=35, slew_step=1.6, min_speed_pct=8, sync_kP=0.12)\n\n    # straight back ~30 ft\n    drive_straight(9140, base_speed_pct=45, kP=0.16, slew_step=1.8, min_speed_pct=10)\n\n    brain.screen.clear_screen()\n    brain.screen.print(\"‚úÖ Auto Done\")\n\n# ---------- run autonomous automatically ----------\nautonomous()\n\n# Keep program alive (prevents exit)\nwhile True:\n    wait(100, MSEC)\n","textLanguage":"python","rconfig":[{"port":[1,2],"name":"LeftSide","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","gear":"ratio18_1","motor_a_reversed":"false","motor_b_reversed":"false"},"triportSourcePort":22},{"port":[9,10],"name":"RightSide","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","gear":"ratio18_1","motor_a_reversed":"false","motor_b_reversed":"false"},"triportSourcePort":22},{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22}],"slot":0,"platform":"V5","sdkVersion":"20220215.18.00.00","appVersion":"2.3.1","fileFormat":"1.0.1","icon":"","targetBrainGen":"First","target":"Physical"}